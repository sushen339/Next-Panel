{{define "modals/outModal"}}
<a-modal id="out-modal" v-model="outModal.visible" :title="outModal.title" @ok="outModal.ok"
         :confirm-loading="outModal.confirmLoading" :closable="true" :mask-closable="false"
         :ok-button-props="{ props: { disabled: !outModal.isValid } }" :style="{ overflow: 'hidden' }"
         :ok-text="outModal.okText" cancel-text='{{ i18n "close" }}' :class="themeSwitcher.currentTheme">
         {{template "form/outbound"}}
</a-modal>
<script>

    const outModal = {
        title: '',
        visible: false,
        confirmLoading: false,
        okText: '{{ i18n "sure" }}',
        isEdit: false,
        confirm: null,
        outbound: new Outbound(),
        jsonMode: false,
        link: '',
        cm: null,
        duplicateTag: false,
        isValid: true,
        activeKey: '1',
        tags: [],
        ok() {
            ObjectUtil.execute(outModal.confirm, outModal.outbound.toJson());
        },
        show({ title='', okText='{{ i18n "sure" }}', outbound, confirm=(outbound)=>{}, isEdit=false, tags=[]  }) {
            this.title = title;
            this.okText = okText;
            this.confirm = confirm;
            this.jsonMode = false;
            this.link = '';
            this.activeKey = '1';
            this.visible = true;
            this.outbound = isEdit ? Outbound.fromJson(outbound) : new Outbound();
            this.isEdit = isEdit;
            this.tags = tags;
            this.check()
        },
        close() {
            outModal.visible = false;
            outModal.loading(false);
        },
        loading(loading=true) {
            outModal.confirmLoading = loading;
        },
        check(){
            if(outModal.outbound.tag == '' || outModal.tags.includes(outModal.outbound.tag)){
                this.duplicateTag = true;
                this.isValid = false;
            } else {
                this.duplicateTag = false;
                this.isValid = true;
            }
        },
        toggleJson(jsonTab) {
            textAreaObj = document.getElementById('outboundJson');
            if(jsonTab){
                if(this.cm != null) {
                        this.cm.toTextArea();
                        this.cm=null;
                }
                textAreaObj.value = JSON.stringify(this.outbound.toJson(), null, 2);
                this.cm = CodeMirror.fromTextArea(textAreaObj, app.cmOptions);
                this.cm.on('change',editor => {
                    value = editor.getValue();
                    if(this.isJsonString(value)){
                        this.outbound = Outbound.fromJson(JSON.parse(value));
                        this.check();
                    }
                });
                this.activeKey = '2';
            } else {
                if(this.cm != null) {
                        this.cm.toTextArea();
                        this.cm=null;
                }
                this.activeKey = '1';
            }
        },
        isJsonString(str) {
            try {
                JSON.parse(str);
            } catch (e) {
                return false;
            }
            return true;
        },
    };

    new Vue({
        delimiters: ['[[', ']]'],
        el: '#out-modal',
        data: {
            outModal: outModal,
            get outbound() {
                return outModal.outbound;
            },
        },
        methods: {
            streamNetworkChange() {
                if (this.outModal.outbound.protocol == Protocols.VLESS && !outModal.outbound.canEnableTlsFlow()) {
                    delete this.outModal.outbound.settings.flow;
                }
            },
            canEnableTls() {
                return this.outModal.outbound.canEnableTls();
            },
            convertLink(){
                newOutbound = Outbound.fromLink(outModal.link);
                if(newOutbound){
                    this.outModal.outbound = newOutbound;
                    this.outModal.toggleJson(true);
                    this.outModal.check();
                    this.$message.success('Link imported successfully...');      
                    outModal.link = '';
                } else {
                    this.$message.error('Wrong Link!');
                    outModal.link = '';
                }
            },
            async generateVlessEncryption() {
                const encType = this.outbound.settings.encryptionType;
                if (!encType || encType === 'none' || encType === 'custom') {
                    return;
                }
                
                try {
                    const msg = await HttpUtil.get('/panel/api/server/getNewVlessEnc');
                    if (msg.success) {
                        const auths = msg.obj.auths;
                        // 根据类型选择对应的密钥
                        const targetAuth = auths.find(auth => {
                            if (encType === 'mlkem768') {
                                return auth.label.includes('ML-KEM-768') || auth.label.includes('Post-Quantum');
                            } else if (encType === 'x25519') {
                                return auth.label.includes('X25519') && !auth.label.includes('Post-Quantum');
                            }
                            return false;
                        });
                        
                        if (targetAuth && targetAuth.encryption) {
                            this.outbound.settings.encryption = targetAuth.encryption;
                            this.$message.success('Encryption密钥已生成');
                        } else {
                            this.$message.error('未找到匹配的加密类型');
                        }
                    } else {
                        this.$message.error('生成失败: ' + msg.msg);
                    }
                } catch (e) {
                    this.$message.error('生成VLESS Encryption失败');
                    console.error(e);
                }
            },
            handleEncryptionTypeChange() {
                // 当选择none时，自动设置encryption为"none"
                if (this.outbound.settings.encryptionType === 'none') {
                    this.outbound.settings.encryption = 'none';
                } else if (this.outbound.settings.encryptionType !== 'custom') {
                    // 清空之前的值，等待用户生成
                    this.outbound.settings.encryption = '';
                }
            },
        },
    });

</script>
{{end}}
